#version 400

in vec3 textureCoords;

layout (location = 0) out vec4 out_Color;
layout (location = 1) out vec4 out_BrightColor;

//uniform samplerCube cubeMap;
//uniform samplerCube cubeMap2;
uniform float blendFactor;
uniform vec3 fogColor;
uniform vec3 WC;
uniform float bF;

uniform float PIC;
uniform float TIME;

uniform vec3 sunDirection;

uniform vec3 timeColor;

uniform sampler2D moonTex;

uniform samplerCube startex;

uniform float STARS;
uniform mat4 starCoordTransform;

const float lowerLimit = 0.0;
const float upperLimit = 30.0;

const float nontexLL = -60;
const float nontexUL = 0.0;

float random(float x){
	return fract(sin(x)*(4782.3256));//+TIME*0.000001
}

float naturalNoise(float x){
	float i = floor(x);
	float f = fract(x);
	return mix(random(i), random(i+1), smoothstep(0., 1.,f));
}

float octaveNoise(float x){
	float ret = 0;
	float divider = 8;
	for(int i = 0; i < 4; i++){
		ret += naturalNoise( x*pow(2, i)/divider )*pow(0.001, i);
	}
	return ret;
}

float hash( vec3 p ){
    return fract( sin(p.x*73.924+p.y*9358.1389+p.z*72.8362) * 45678.9123 );
}

const float PI = 3.1415;
const vec4 sunColor = vec4(1.0);

//const float moonAng = 3*PI/180;
//const float moonSize = 1-cos(moonAng);//0.0004
//const float dMoon = sin(moonAng);
//const float dMoonM = 0.5/dMoon;

const float sunsize = 0.002;
const float suncircle = 0.001;
const float redoffset = -0.1;

uniform vec3 moonStuff;

uniform float showMoon;

void main(void){
	
	float moonSize = moonStuff.x;
	float dMoon = moonStuff.y;
	float dMoonM = moonStuff.z;
	
	vec4 finalColor = vec4(0.0);
	
    vec3 normTex = normalize(textureCoords);
    
    //float RAND = ((normTex.y+ normTex.x*4289*normTex.z ) * TIME/100);
    	
	//if(PIC > 0.5){
	//    
	//	vec4 tex1 = texture(cubeMap, textureCoords);
	//	vec4 tex2 = texture(cubeMap2, textureCoords);
	//	finalColor = mix(tex1, tex2, blendFactor);
	//	finalColor = mix(finalColor, vec4(WC, 1.0), bF);
	//	
	//    float fact = (textureCoords.y - lowerLimit) / (upperLimit - lowerLimit);
	//    fact = clamp(fact, 0.0, 1.0);
	//    out_Color = mix(vec4(fogColor, 1.0), finalColor, fact);
	//    out_BrightColor = 0.2*out_Color;//mix(out_Color, vec4(0.0), 0.5)
    //}else{
    	//float s = sin(TIME*PI/24); ?
    	//float r = naturalNoise(s*(textureCoords.x*2+textureCoords.y*8.29*textureCoords.z)/100);
    	//out_Color = vec4(r, r, r, 1.0);
    	//out_Color = vec4(mix(vec3(0.01, 0.01, 0.2), vec3(0.01, 0.01, 0.35), (1+textureCoords.y/2)*0.1), 1.0);
    	
    	//out_Color = vec4(0.3, 0.3, 1, 1.0);
    	//out_Color = mix(out_Color, vec4(0, 0, 0, 1.0), blendFactor); // WORKS PRETTY WELL
    	out_Color = vec4(timeColor, 1.0);
    	if(normTex.y < 0){
    		if(normTex.y > -0.4){
    			out_Color = mix(vec4(0.0, 0.0, 0.0, 1.0), out_Color, 1+(normTex.y*2.5));
    		}else{
    			out_Color = vec4(0.0, 0.0, 0.0, 1.0);
    		}
    	}
    	
    	if(false){// JUST FOR TESTS!!! Macht (fast) hypnotisierende Muster am Himmel
    		float xfact = sin(TIME)*100;
    		float yfact = sin(TIME*0.3+932.02)*100;
    		float zfact = cos(TIME*0.93)*100;
    		out_Color = mix(out_Color, vec4(1, 1, 1, 1.0),
    		naturalNoise(sin(normTex.x*xfact)+cos(normTex.y*yfact)+sin(normTex.z*zfact+429.432) ) );
    	}
    	//float starval = 0;
    	//for(float y = -0.01; y <= 0.01; y+=0.01){
    	//	for(float x = -0.01; x <= 0.01; x+=0.01){
    	//		for(float z = -0.01; z <= 0.01; z+=0.01){
    	//			if(texture(startex, vec3(textureCoords.x+x, textureCoords.y+y, textureCoords.z+z)).x > 0.5){
    	//				starval += 0.1;
    	//			}
    	//		}
    	//	}
    	//}
    	//if(STARS > 0.5 && starval > 0.5){
    	//	out_Color = vec4(1.0);
    	//}
    	
    	//float sunangle = asin(sunDirection.y);
    	//float texangle = asin(normTex.y);
    	//if(normTex.x < 0){
    	//	if(texangle < 0){
    	//		texangle = PI+abs(texangle);
    	//	}else{
    	//		texangle = acos(normTex.x);
    	//	}
    	//}
    	//float diff = sunangle+texangle-PI*0.5;
    	
    	vec3 starSampleCoords = (vec4(normTex, 1.0) * starCoordTransform).xyz;
    	if(abs(starSampleCoords.x) >= abs(starSampleCoords.y) && abs(starSampleCoords.x) >= abs(starSampleCoords.z)){
    		starSampleCoords *= 1/starSampleCoords.x;
    	}else if(abs(starSampleCoords.y) >= abs(starSampleCoords.x) && abs(starSampleCoords.y) >= abs(starSampleCoords.z)){
    		starSampleCoords *= 1/starSampleCoords.y;
    	}else{
    		starSampleCoords *= 1/starSampleCoords.z;
    	}
    	
    	vec4 STEX = texture(startex, starSampleCoords);
    	
    	out_Color = mix(out_Color, STEX, blendFactor);
    	
    	out_Color = vec4(mix(out_Color.xyz, WC, bF), 1.0);
    	//out_Color = vec4(WC, 1.0);
   		
    	finalColor = out_Color;
    	out_BrightColor = vec4(0.0);
   	//}
   
  	//if(normTex.y > -0.2){
	    float dotpr = dot(sunDirection, normTex);
	    if(dotpr >= 1-sunsize){
	  	  	float vis = 1;
	    	if(dotpr < 1-suncircle){
		    	out_Color = sunColor;
		    	vis = min(0, (1-sunsize)/dotpr);
		    	//out_Color = vec4(1, 1, 0.7, 1.0);
			}else{
				out_Color = sunColor;
			}
		    float reddot = dot( normalize(vec3(1, redoffset, 0)), sunDirection);//normTex
		   	const float redcap = 0.97;
		    if(reddot > redcap){
		    	out_Color = mix(out_Color, vec4(1, 0.2, 0.2, 1.0), 1-(100*(1-reddot)) );
		    }else{
		    	reddot = dot( normalize(vec3(-1, redoffset, 0)), sunDirection);//normTex
		    	if(reddot > redcap){
		    		out_Color = mix(out_Color, vec4(1, 0.2, 0.2, 1.0), 1-(100*(1-reddot)) );
		    	}
		    }
		    if(vis < 1){
		    	out_Color = mix(out_Color, finalColor, 1-vis);
		    }
		    out_BrightColor = out_Color*10;
	    }else if(showMoon > 0.5 && dotpr <= moonSize-1){
	    	float moondot = -dotpr;
	    	vec3 texC = (vec4(normTex, 1.0) * -starCoordTransform).xyz;
	    	vec2 tC = vec2((texC.z+dMoon)*dMoonM, (texC.x+dMoon)*dMoonM);
	    	out_Color = texture(moonTex, tC);
	    	out_BrightColor = 0.5*out_Color;
	    }
	//}
    
    //out_Color = vec4(1.0, 1.0, 1.0, 1.0);
    
}
